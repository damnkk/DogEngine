#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive :enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64:require
#extension GL_EXT_scalar_block_layout :enable
#extension GL_ARB_shader_clock : enable
#include "shaderDataStructure.h"
#include "shaderUtil.glsl"
layout(location = 0) rayPayloadEXT hitPayLoad prd;

layout(set = 0,binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0,binding = 1,rgba32f) uniform image2D outputImage;
layout(set = 1,binding = 0) uniform cameraTransform{
    vec3 cameraPos;
    vec3 cameraDirection;
    mat4 viewMatrix;
    mat4 projMatrix;
}cameraTrans;

layout(push_constant,scalar) uniform RtPushConstant{
    int frameCount;
    int maxBound;
    int skyTextureBindlessIdx;
    vec4 clearColor;
}rtConst;

vec2 hammersley2d(uint i, uint N)
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    uint bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    float rdi = float(bits) * 2.3283064365386963e-10;
    return vec2(float(i) /float(N), rdi);
}

void main(){
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));

    vec2 pixelOffset = hammersley2d(rtConst.frameCount%10000,10000);
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy+(pixelOffset-0.5))+vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 NDCxy = inUV*2.0f-1.0f;
    //camera pos
    vec3 origin = cameraTrans.cameraPos;
    vec4 target = inverse(cameraTrans.projMatrix)*vec4(NDCxy.x,NDCxy.y,1,1);
    vec4 rayDir = inverse(cameraTrans.viewMatrix)*vec4(normalize(target.xyz),0);

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin = 0.001;
    float tMax=  100000.0;
    prd.origin = origin;
    prd.direction = rayDir.xyz;
    prd.recursiveDepth = 0;
    prd.hitValue = vec3(0.0f);
    prd.weight = vec3(1.0f);
    prd.seed = seed;

    vec3 acculuLight= vec3(0.0f);
    vec3 weight = vec3(1.0f);

    for(;prd.recursiveDepth<5 ;prd.recursiveDepth++){
        traceRayEXT(topLevelAS,
        rayFlags,
        0xFF,
        0,0,0,prd.origin,tMin,prd.direction, tMax,0);
        acculuLight += weight*prd.hitValue;
        weight*=prd.weight;
    }

    if(rtConst.frameCount<=1){
        imageStore(outputImage,ivec2(gl_LaunchIDEXT.xy),vec4(acculuLight,1.0f));
    }else{
        float a = 1.0f/float(rtConst.frameCount+1);
        vec3 oldColor = imageLoad(outputImage,ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(outputImage,ivec2(gl_LaunchIDEXT.xy),vec4(mix(oldColor,acculuLight,a),1.0f));
    }


    // traceRayEXT(topLevelAS,
    //     rayFlags,
    //     0xFF,
    //     0,0,0,prd.origin,tMin,prd.direction, tMax,0);
    // imageStore(outputImage,ivec2(gl_LaunchIDEXT.xy),vec4(prd.hitValue.xyz,1.0f));
}
